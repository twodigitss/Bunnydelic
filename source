#!/usr/bin/env python
import os, platform, random, socket, sys, subprocess
sys.path.append(f"{os.path.expanduser('~')}/.config/bunnydelic/"); from config import *

''' /////////////// STYLES ////////////// '''

asciiisdefault=True;  #was the default_ascii replaced?
if show_phrase is False: phraseToLeft=False; 
else: pass
end = "\033[0m"; bold= "\033[1m"; c1=""; c2="";c3="";c4=""
line= "\033[4m"; ital= "\033[3m"; f1=""; f2="";f3="";f4=""

colorkeywords={ #used to read vars from config file
    "red":"red", "blue":"ble", "green":"grn", "yellow":"ylw", 
    "purple":"prp", "cyan":"cyn", "white":"wht", "black":"blk"
}
fg={ #normal foreground colors
    "red":  "\033[0;31m",   "grn":  "\033[0;32m",   
    "ylw":  "\033[0;33m",   "ble":  "\033[0;34m",
    "prp":  "\033[0;35m",	"cyn":  "\033[0;36m",
    "wht":  "\033[0;37m",   "blk":  "\033[0;30m",   
}
bg={ #normal background colors that paints a two-spaced square
    "red":"\033[0;41m  \033[0m", "grn":"\033[0;42m  \033[0m",
    "ylw":"\033[0;43m  \033[0m", "ble":"\033[0;44m  \033[0m",
    "prp":"\033[0;45m  \033[0m", "cyn":"\033[0;46m  \033[0m",
    "wht":"\033[0;47m  \033[0m", "blk":"\033[0;40m  \033[0m",
}
faces={ #56 in total, feel freee to add more if you want
    "a1":"- -", "a2":"-_-", "a3":"-u-", "a4":"-o-", "a5":"-w-", "a6":"-.-", "a7":"-^-",
    "b1":"'-'", "b2":"'_'", "b3":"'u'", "b4":"'o'", "b5":"'w'", "b6":"'.'", "b7":"'^'",
    "c1":"O-o", "c2":"O_o", "c3":"Ouo", "c4":"O O", "c5":"OwO", "c6":"O.O", "c7":"O^O",
    "d1":"U-u", "d2":"U_u", "d3":"U U", "d4":"Uou", "d5":"Uwu", "d6":"U.u", "d7":"U^u",
    "e1":">-<", "e2":">_<", "e3":">u<", "e4":">o<", "e5":">w<", "e6":">.<", "e7":">^<",
    "f1":"T-T", "f2":"T_T", "f3":"TuT", "f4":"ToT", "f5":"TwT", "f6":"T.T", "f7":"T^T",
    "g1":"7-7", "g2":"7_7", "g3":"7u7", "g4":"7o7", "g5":"7w7", "g6":"7.7", "g7":"7^7",
    "h1":"^-^", "h2":"^_^", "h3":"^u^", "h4":"^o^", "h5":"^w^", "h6":"^.^", "h7":"^ ^",
}
distros={ #Robotition suggested this, thank him :>
    "Arch Linux":"",        "Debian GNU/Linux":"",  "EndeavourOS":"",   "Manjaro Linux":"󱘊",     "NixOS":"",
    "Ubuntu":"",            "Pop!_OS":"",           "Fedora":"󰣛",        "Crystal Linux":"",     "Void Linux":"",
    "Kali GNU/Linux":"",    "Rocky Linux":"",       "Linux Mint":"󰣭",    "AlmaLinux":"",         "Alphine Linux":"",
    "Archcraft":"",         "ArchLabs":"",          "ArcoLinux":"",     "Artix Linux":"",       "BigLinux":"",
    "CentOS Linux":"",      "Devuan GNU/Linux":"",  "elementary OS":"", "Hyperbola GNU/Linux-libre":"",
    "MX Linux":"",          "openSUSE":"",          "Void":"",          "Zorin OS":"",          "Trisquel GNU/Linux":"",
    "Garuda Linux":"",      "Gentoo Linux":"",      "Loc-os":"",        "Parabola GNU/Linux-libre":"",
    "Puppy Linux":"",       "Parrot":"",            "Linux":"",
}

#Randomize and sort faces and colors
fg_list = list(fg.keys()); bgkey = list(bg.keys())
face_list = list(faces.keys()); random.shuffle(face_list)
if randomize_colors: random.shuffle(fg_list)
else: fg_list = [colorkeywords[color] for color in static_color_set]
#match bgkey with the order set in fg_list
bgkey = [bg_key for fg_key in fg_list for bg_key in bg if fg_key == bg_key]
bgblocks="".join([bg[bg_key] for fg_key in fg_list for bg_key in bg if fg_key == bg_key])

c1 = fg[fg_list[0]];  f1 = faces[face_list[0]]
c2 = fg[fg_list[1]];  f2 = faces[face_list[1]]
c3 = fg[fg_list[2]];  f3 = faces[face_list[2]]
c4 = fg[fg_list[3]];  f4 = faces[face_list[3]]

#default ascii art (do not touch pls)
default_ascii=f'''
(\ /)    (\ /)  
( {f1})   ( {f2}) 
c({c1}"{end})({c1}"{end})  c({c2}"{end})({c2}"{end})
                
(\ /)    (\ /)  
( {f3})   ( {f4}) 
c({c3}"{end})({c3}"{end})  c({c4}"{end})({c4}"{end})
'''

if show_ascii=="default": pass
if show_ascii=="custom":
    if not custom_ascii: pass;
    else:#also ensures length uniformity in custom_ascii
        newascii = custom_ascii.strip().split('\n')
        max_length = max(len(line) for line in newascii)
        newFormat=[line.ljust(max_length, ' ') for line in newascii]; #!!!
        if phraseToLeft is True: default_ascii = "\n" + '\n'.join(newFormat) + '\n'
        else: default_ascii = "" + '\n'.join(newFormat) + '\n'
        asciiisdefault=False

''' /////////////// FETCH ////////////// '''

# Array with each life of ascii art and a custom auto-adjustable spacer
ascii_lines= default_ascii.split('\n'); max_lines =  0;
spacer=" " * max(len(line) for line in ascii_lines) if not asciiisdefault else " " * 16

# functions to fetch information
def get_user(): return os.getlogin()
def get_host(): return socket.gethostname()
def get_sh(): return os.environ.get('SHELL')
def get_de(): 
    if os.environ.get('XDG_CURRENT_DESKTOP') is None: 
        return os.environ.get('XDG_SESSION_DESKTOP')
    else: return os.environ.get('XDG_CURRENT_DESKTOP')
def get_kern(): return f"{platform.uname().release}"
def get_os():
    return subprocess.run(
    "grep '^NAME=' /etc/os-release | awk -F '=' '{print $2}' | tr -d '\"'", 
    shell=True, capture_output=True, text=True).stdout.strip()
def get_cpu():
    return subprocess.run(
    "lscpu | awk '/Model name/ {print $3, $4, $5, $6}'", 
    shell=True, capture_output=True, text=True).stdout.strip()
def get_ram():
    ram_all=subprocess.run("free -h | awk '/^Mem/ {print $2}'", 
    shell=True, capture_output=True, text=True).stdout.strip()
    ram_use=subprocess.run("free -h | awk '/^Mem/ {print $3}'", 
    shell=True, capture_output=True, text=True).stdout.strip()
    return f"{ram_use} ~ {ram_all}"
def get_hdw():
    return subprocess.run(
    "cat /sys/class/dmi/id/product_name", 
    shell=True, capture_output=True, text=True).stdout.strip()
def get_gpu():
    return subprocess.run(
    "lspci | grep -iE 'VGA|3D|Display' | awk -F '[:[:space:]]+' '{print $6,$7,$8,$9,$10}'", 
    shell=True, capture_output=True, text=True).stdout.strip()
def get_upt(): 
    with open('/proc/uptime', 'r') as file:
        uptime_seconds = int(float(next(file).split()[0]))
        uptime_hours, uptime_minutes = divmod(uptime_seconds // 60, 60)
        return f"{uptime_hours} hours, {uptime_minutes} minutes"
def get_pkg():
   if os.path.exists('/etc/pacman.conf'):
       return len(os.popen("pacman -Qq").readlines())
   elif os.path.exists('/etc/apt/sources.list') or os.path.exists('/etc/apt'): 
       result = subprocess.run(['dpkg', '-l'], capture_output=True, text=True)
       return len(result.stdout.splitlines()) - 5 #substract header file
   elif os.path.exists('/etc/dnf/dnf.conf') or os.path.exists('/etc/yum'): 
       result = subprocess.run(['dnf', 'list', 'installed'], capture_output=True, text=True)
       return len(result.stdout.splitlines()) - 1 #substract header file
   else: return "unsupported"

if override_distro_icon is True:
    your_distro=get_os()
    for item in distros:
        if item==your_distro: icons[0]=distros[item]
        else: pass
else: pass

#this is a LIST of every line to print
info_lines=f'''{somephrases[random.randint(0,len(somephrases)-1)]}
{icons[0]}  Distro:   {end}{get_os()} 
{icons[1]}  Owner:    {end}{get_host()} {get_user()}
{icons[2]}  Kernel:   {end}{get_kern()} 
{icons[3]}  Desk:     {end}{get_de()}
{icons[4]}  Pkgs:     {end}{get_pkg()}
{icons[5]}  Shell:    {end}{get_sh()} 
{icons[6]}  Uptime:   {end}{get_upt()}
{icons[7]}  Ram:      {end}{get_ram()}
{icons[8]}  Cpu:      {end}{get_cpu()}
{icons[9]}  Device:   {end}{get_hdw()}
{icons[10]}  Graphic:  {end}{get_gpu()}
{icons[11]}  User:     {end}{get_user()}
{icons[12]}  Host:     {end}{get_host()}
'''.split('\n')

dictOfLines={
    "distro":info_lines[1], "owner":info_lines[2],   "kernel":info_lines[3], 
    "de":info_lines[4],     "pkg":info_lines[5],     "shell":info_lines[6],      
    "uptime":info_lines[7], "ram": info_lines[8],    "cpu":info_lines[9],    
    "gpu": info_lines[11],  "user": info_lines[12],  "host": info_lines[13],  
    "model":info_lines[10],
}

#MAIN METHOD
if __name__=="__main__":
    #Sort the information as "display" variable
    info_lines=info_lines[:1]; #exclude the first line
    for item in display:
        if item in dictOfLines: info_lines.append(dictOfLines[item.lower()])
        else: pass

    #remove nerd font icons
    if show_icons is True: pass
    else:#removes the glyph + empty spaces
        for i in range(1, len(info_lines)):
            info_lines[i] = info_lines[i][3:]

    if color_block_position=="bottom":
        info_lines=info_lines+[f"{end}"]+[f"{bgblocks}"]
    else: pass

    # what to show if ascii is removed
    if show_ascii == "off":
        info_lines=info_lines[1:] if not show_phrase else info_lines
        max_lines = len(info_lines)+1;
        for i in range(max_lines):
            info_column = info_lines[i]  if i < len(info_lines)  else ''
            
            if color_block_position=="left": #LEFT 
                if not show_phrase:
                      fg_column=f"{bg[bgkey[i]]} {fg[fg_list[i]]}"   if i < len(bgkey) else f'{bg["wht"]} {fg["wht"]}'
                else: fg_column=f"{bg[bgkey[i-1]]} {fg[fg_list[i-1]]}" if i < len(bgkey)+1 else f'{bg["wht"]} {fg["wht"]}'
            elif color_block_position=="bottom" or color_block_position=="off": #DOWN
                if not show_phrase: 
                      fg_column=f"{fg[fg_list[i]]}"   if i < len(bgkey) else f'{fg["wht"]}'
                else: fg_column=f"{fg[fg_list[i-1]]}"   if i < len(bgkey)+1 else f'{fg["wht"]}'
            else: fg_column="invalid choice"

            if i==0: print(f"{fg_column}{info_column}" if not show_phrase else f"{info_column}")
            else: 
                if not info_column:
                    if   color_block_position=="left" or color_block_position=="off": print(f"")
                    elif color_block_position=="bottom": print(f"{fg_column}{info_column}")
                else: print(f"{fg_column}{info_column}")

    else:# show whatever ascii if no set "off"
        if show_phrase is False:
            info_lines = info_lines[1:]
            ascii_lines= ascii_lines[1:] if asciiisdefault else ascii_lines
        max_lines = len(ascii_lines) if len(ascii_lines) > len(info_lines) else len(info_lines)+1

        for i in range(max_lines):
            ascii_column  = ascii_lines[i] if i < len(ascii_lines) else spacer
            info_column = info_lines[i]  if i < len(info_lines)  else ''
            #dude, how the hell is this long? i seriously need to optimize this somehow
            if color_block_position=="left": #LEFT 
                if not show_phrase:
                      fg_column=f"{bg[bgkey[i]]} {fg[fg_list[i]]}"   if i < len(bgkey) else f'{bg["wht"]} {fg["wht"]}'
                else: fg_column=f"{bg[bgkey[i-1]]} {fg[fg_list[i-1]]}" if i < len(bgkey)+1 else f'{bg["wht"]} {fg["wht"]}'
            elif color_block_position=="bottom" or color_block_position=="off": #DOWN
                if not show_phrase: 
                      fg_column=f"{fg[fg_list[i]]}"   if i < len(bgkey) else f'{fg["wht"]}'
                else: fg_column=f"{fg[fg_list[i-1]]}"   if i < len(bgkey)+1 else f'{fg["wht"]}'
            else: fg_column=""
            
            if i==0:# DO NO forget that this instruction is for printing only the phrase
                if show_phrase:
                    if asciiisdefault or phraseToLeft: print(f"{ascii_column}{info_column}")
                    else: print(f"{ascii_column}   {info_column}")
                else: print(f"{ascii_column}   {fg_column}{info_column}")
            
            else:# From here prints the body
                if ascii_column:
                    if not info_column:
                        if color_block_position=="left" or color_block_position=="off": 
                            print(f"{ascii_column}");
                        elif color_block_position=="bottom": 
                            print(f"{ascii_column}   {fg_column}{info_column}"); #ADDED MIDDLE COLUMN
                            #else: print("\n"+f"{spacer}   {bgblocks}"+"\n")
                    else: print(f"{ascii_column}   {fg_column}{info_column}");# si no hay info el fg si se imprime
                
                else:
                    if color_block_position=="left" or color_block_position=="off": 
                        if info_column: print(f"{spacer}   {fg_column}{info_column}")
                        else: print(f"{spacer}   ")
                    elif color_block_position=="bottom": 
                        if info_column: print(f"{spacer}   {fg_column}{info_column}"); 
                        else: print("")
                    else: print(f"{ascii_column}   {fg_column}{info_column}")
                    
